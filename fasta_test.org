#+begin_src latex
  \section{Testing}
  We import the \texttt{testing} package and add hooks for further
  imports and functions.
#+end_src
#+begin_src go <<fasta_test.go>>=
  package fasta

  import (
	  "testing"
	  //<<Testing imports>>
  )
  //<<Testing functions>>
#+end_src
#+begin_src latex
  \subsection{\texttt{Sequence}}
  \subsubsection{Method \texttt{Equals}}
  We start by testing \texttt{Equals}.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestEquals(t *testing.T) {
	  //<<Test \texttt{Equals}>>
  }
#+end_src
#+begin_src latex
  First, compare two identical sequences.
#+end_src
#+begin_src go <<Test \texttt{Equals}>>=
  d1 := []byte("ACCGT")
  s1 := NewSequence("s1", d1)
  s2 := NewSequence("s1", d1)
  if !(s1.Equals(s2) && s2.Equals(s1)) {
	  t.Error("equal sequences declared unequal")
  }
#+end_src
#+begin_src latex
  Now compare two sequences with different headers.
#+end_src
#+begin_src go <<Test \texttt{Equals}>>=
  s3 := NewSequence("s3", d1)
  if s1.Equals(s3) || s3.Equals(s1) {
	  t.Error("sequences with unequal headers declared equal")
  }
#+end_src
#+begin_src latex
  As a last test of \texttt{Equals}, we compare a pair of sequences with
  differing data.
#+end_src
#+begin_src go <<Test \texttt{Equals}>>=
  d2 := []byte("ACGGT")
  s4 := NewSequence("s1", d2)
  if s1.Equals(s4) || s4.Equals(s1) {
	  t.Error("sequences with unequal data declared equal")
  }
#+end_src
#+begin_src latex
  \subsubsection{Method \texttt{String}}
  We test \texttt{String} on a sequence of five nucleotides. This is
  printed with line lengths 4, 5, 10, and $\infty$; in other words,
  shorter than the sequence, as long as the sequence, longer than the
  sequence, and ``infinitely'' long, which is denoted by any length less
  than 1.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestString(t *testing.T) {
	  seq := NewSequence("seq", []byte("ACCGT"))
	  ll := []int{4, 5, 10, 0}
	  for _, l := range ll {
		  //<<Test \texttt{String}>>
	  }
  }
#+end_src
#+begin_src latex
  In it we use \texttt{String} to write a \texttt{Sequence} to file,
  which is then retrieved and checked.
#+end_src
#+begin_src go <<Test \texttt{String}>>=
  //<<Write a \texttt{Sequence} to file>>
  //<<Read the \texttt{Sequence} from file>>
  //<<Check the \texttt{Sequence}>>
#+end_src
#+begin_src latex
  We construct a sequence with a line length less than the sequence
  length and write it to a new temporary file.
#+end_src
#+begin_src go <<Write a \texttt{Sequence} to file>>=
  seq.SetLineLength(l)
  f, _ := ioutil.TempFile("", "test_*")
  fmt.Fprintf(f, "%s\n", seq)
  f.Close()
#+end_src
#+begin_src latex
  We import the packages \texttt{ioutil} and \texttt{fmt}.
#+end_src
#+begin_src go <<Testing imports>>=
  "io/ioutil"
  "fmt"
#+end_src
#+begin_src latex
  The sequence is read as a byte slice from the file and split at the
  newlines. As we're done with the file at this point, we remove it.
#+end_src
#+begin_src go <<Read the \texttt{Sequence} from file>>=
  b1, _ := ioutil.ReadFile(f.Name())
  b2 := bytes.Split(b1, []byte("\n"))
  os.Remove(f.Name())
#+end_src
#+begin_src latex
  The packages \texttt{bytes} and \texttt{os} are new.
#+end_src
#+begin_src go <<Testing imports>>=
  "bytes"
  "os"
#+end_src
#+begin_src latex
  When checking the \texttt{Sequence}, we start with the header, then
  look at the data, and finally test the formatting.
#+end_src
#+begin_src go <<Check the \texttt{Sequence}>>=
  //<<Check header>>
  //<<Check data>>
  //<<Check formatting>>
#+end_src
#+begin_src latex
  The headers are compared.
#+end_src
#+begin_src go <<Check header>>=
  h := string(b2[0][1:])
  if h != seq.Header() {
	  t.Errorf("did not write header correctly; " +
		  "want %q; get %q\n", h, seq.Header())
  }
#+end_src
#+begin_src latex
  The data is checked byte-wise.
#+end_src
#+begin_src go <<Check data>>=
  var counter int
  for i, s := range b2 {
	  if i < 1 {
		  continue
	  }
	  for _, c := range s {
		  d := seq.Data()
		  if c != d[counter] {
			  t.Error("did not write data correctly")
		  }
		  counter++
	  }
  }
#+end_src
#+begin_src latex
  Compare the expected position of the newline with that observed.
#+end_src
#+begin_src go <<Check formatting>>=
    if l <= 5 && l > 0 {
	    if len(b2[1]) != l {
		    t.Errorf("did not format data correctly: " +
				  "want: %d; get: %d", l, len(b2[1]))
	    }
    }
#+end_src
#+begin_src latex
  \subsubsection{Method \texttt{Shuffle}}
  We generate a sequence and its shuffled version when seeding
  the random number generator with 13. Then we shuffle the original and
  compare what we get to what we want.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestShuffle(t *testing.T) {
    orig := NewSequence("", []byte("ACCGT"))
    shuf := []byte("GTACC")
    r := rand.New(rand.NewSource(13))
    orig.Shuffle(r)
    if !bytes.Equal(orig.data, shuf) {
	    t.Errorf("want:\n%s\nget:\n%s\n",
		    string(shuf),
		    string(orig.data))
    }
  }
#+end_src
#+begin_src latex
  We import \texttt{math/rand}.
#+end_src
#+begin_src go <<Testing imports>>=
  "math/rand"
#+end_src
#+begin_src latex
  \subsubsection{Method \texttt{Reverse}}
  We start with a \texttt{Sequence} and its reverse. Then we reverse the
  original and check whether we get what we want.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestReverse(t *testing.T) {
    ori := NewSequence("", []byte("ACCGT"))
    rev := []byte("TGCCA")
    ori.Reverse()
    if !bytes.Equal(ori.data, rev) {
	    t.Errorf("want:\n%s\nget:\n%s\n",
		    string(rev),
		    string(ori.data))
    }
  }
#+end_src
#+begin_src latex
  \subsubsection{Method \texttt{ReverseComplement}}
  We generate a short \texttt{Sequence} and its reverse complement. Then
  we reverse-complement the original and compare what we want to what we get.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestReverseComplement(t *testing.T) {
    ori := NewSequence("", []byte("ACCGT"))
    rc  := []byte("ACGGT")
    ori.ReverseComplement()
    if !bytes.Equal(ori.data, rc) {
	    t.Errorf("want:\n%s\nget:\n%s\n",
		    string(rc),
		    string(ori.data))
    }
  }
#+end_src

#+begin_src latex
  \subsection{\texttt{Scanner}}
  The \texttt{Scanner} is tested by reading and writing nine of files,
  which cover the following cases:
  \begin{center}
    \begin{tabular}{ll}
      \hline
      Name & Content\\\hline
      \texttt{seq1.fasta} & empty file\\
      \texttt{seq2.fasta} & empty header, no data\\
      \texttt{seq3.fasta} & header, no data\\
      \texttt{seq4.fasta} & 1 sequence with 5 nucleotides\\
      \texttt{seq5.fasta} & 2 sequences with 70 nucleotides each\\
      \texttt{seq6.fasta} & 2 sequences with 140 nucleotides each\\
      \texttt{seq7.fasta} & 5 sequences with 700 nucleotides each\\
      \texttt{seq8.fasta} & 5 sequences with 1000 nucleotides each\\
      \texttt{seq9.fasta} & 5 sequences with 1000 nucleotides each and
      no terminal newline\\
      \hline
      \end{tabular}
  \end{center}
  We read each of these eight files, write the sequences to file, and,
  if a sequence was found, compare the copy with the original.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestScanner(t *testing.T) {
	  for i := 1; i <= 9; i++ {
		  //<<Open files>>
		  //<<Read and write files>>
		  if foundSequence {
			  //<<Compare files>>
		  }
		  //<<Delete files>>
	  }
  }
#+end_src
#+begin_src latex
  Open the input and output files.
#+end_src
#+begin_src go <<Open files>>=
  name := "./data/seq" + strconv.Itoa(i) + ".fasta"
  in, err := os.Open(name)
  if err != nil {
	  t.Errorf("couldn't open %q\n", name)
  }
  out, _ := ioutil.TempFile(".", "test_*")
#+end_src
#+begin_src latex
  We import  \texttt{strconv}.
#+end_src
#+begin_src go <<Testing imports>>=
  "strconv"
#+end_src
#+begin_src latex
  Sequences are read via a \texttt{Scanner} and written by implicit
  calls to the \texttt{String} method of \texttt{Sequence}.
#+end_src
#+begin_src go <<Read and write files>>=
  scanner := NewScanner(in)
  var foundSequence = false
  for scanner.ScanSequence() {
	  foundSequence = true
	  seq := scanner.Sequence()
	  fmt.Fprintf(out, "%s\n", seq)
  }
  in.Close()
  out.Close()
#+end_src
#+begin_src latex
  To compare files, their contents are compared.
#+end_src
#+begin_src go <<Compare files>>=
  id, _ := ioutil.ReadFile(name)
  if i == 9 {
	  id = append(id, '\n')
  }
  od, _ := ioutil.ReadFile(out.Name())
  if !bytes.Equal(id, od) {
	  t.Errorf("failed to reproduce %q\n", name)
  }
#+end_src
#+begin_src latex
  The temporary output files aren't needed any more, so we delete them.
#+end_src
#+begin_src go <<Delete files>>=
  os.Remove(out.Name())
#+end_src
#+begin_src latex
  \subsection{\texttt{Flush}}
  We test \ty{Flush} by scanning a file terminated by newline and a file
  terminated by EOF. Both should contain the same number of significant
  bytes.
#+end_src
#+begin_src go <<Testing functions>>=
  func TestFlush(t *testing.T) {
	  //<<Test \ty{Flush} with newline>>
	  //<<Test \ty{Flush} without EOF>>
  }
#+end_src
#+begin_src latex
  File \ty{seq8.fasta} contains 5085 significant bytes and is terminated
  by a newline.
#+end_src
#+begin_src go <<Test \ty{Flush} with newline>>=
  f, _ := os.Open("data/seq8.fasta")
  sc := NewScanner(f)
  w := 5085
  g := 0
  for sc.ScanLine() {
	  g += len(sc.Line())
  }
  g += len(sc.Flush())
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
  f.Close()
#+end_src
#+begin_src latex
  File \ty{seq9.fasta} also contains 5080 significant bytes but is
  terminated by EOF.
#+end_src
#+begin_src go <<Test \ty{Flush} without EOF>>=
  f, _ = os.Open("data/seq9.fasta")
  sc = NewScanner(f)
  g = 0
  for sc.ScanLine() {
	  g += len(sc.Line())
  }
  g += len(sc.Flush())
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
  f.Close()
#+end_src

